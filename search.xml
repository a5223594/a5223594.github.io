<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>缓存和数据库双写不一致</title>
      <link href="/2019/09/06/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
      <url>/2019/09/06/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="最初级的缓存不一致问题以及解决方案"><a href="#最初级的缓存不一致问题以及解决方案" class="headerlink" title="最初级的缓存不一致问题以及解决方案"></a>最初级的缓存不一致问题以及解决方案</h2><p>问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致<br>解决思路<br>先删除缓存，再修改数据库，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致<br>因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中</p><h2 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h2><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改<br>一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中<br>数据变更的程序完成了数据库的修改<br>完了，数据库和缓存中的数据不一样了。。。。<br>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题<br>其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景</p><h2 id="数据库与缓存更新与读取操作进行异步串行化"><a href="#数据库与缓存更新与读取操作进行异步串行化" class="headerlink" title="数据库与缓存更新与读取操作进行异步串行化"></a>数据库与缓存更新与读取操作进行异步串行化</h2><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中<br>读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中<br>一个队列对应一个工作线程<br>每个工作线程串行拿到对应的操作，然后一条一条的执行<br>这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新<br>此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成<br>这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可<br>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中<br>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值</p><h2 id="该解决方案要注意的问题"><a href="#该解决方案要注意的问题" class="headerlink" title="该解决方案要注意的问题"></a>该解决方案要注意的问题</h2><ol><li>读请求长时阻塞<br>由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回<br>该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库<br>务必通过一些模拟真实的测试，看看更新数据的频繁是怎样的<br>另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作<br>如果一个内存队列里居然会挤压100个商品的库存修改操作，每隔库存修改操作要耗费10ms区完成，那么最后一个商品的读请求，可能等待10 * 100 = 1000ms = 1s后，才能得到数据<br>这个时候就导致读请求的长时阻塞<br>一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会hang多少时间，如果读请求在200ms返回，如果你计算过后，哪怕是最繁忙的时候，积压10个更新操作，最多等待200ms，那还可以的<br>如果一个内存队列可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少<br>其实根据之前的项目经验，一般来说数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的<br>针对读高并发，读缓存架构的项目，一般写请求相对读来说，是非常非常少的，每秒的QPS能到几百就不错了<br>一秒，500的写操作，5份，每200ms，就100个写操作<br>单机器，20个内存队列，每个内存队列，可能就积压5个写操作，每个写操作性能测试后，一般在20ms左右就完成<br>那么针对每个内存队列中的数据的读请求，也就最多hang一会儿，200ms以内肯定能返回了<br>写QPS扩大10倍，但是经过刚才的测算，就知道，单机支撑写QPS几百没问题，那么就扩容机器，扩容10倍的机器，10台机器，每个机器20个队列，200个队列<br>大部分的情况下，应该是这样的，大量的读请求过来，都是直接走缓存取到数据的<br>少量情况下，可能遇到读跟数据更新冲突的情况，如上所述，那么此时更新操作如果先入队列，之后可能会瞬间来了对这个数据大量的读请求，但是因为做了去重的优化，所以也就一个更新缓存的操作跟在它后面<br>等数据更新完了，读请求触发的缓存更新操作也完成，然后临时等待的读请求全部可以读到缓存中的数据</li><li>读请求并发量过高<br>这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值<br>但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大<br>按1:99的比例计算读和写的请求，每秒5万的读QPS，可能只有500次更新操作<br>如果一秒有500的写QPS，那么要测算好，可能写操作影响的数据有500条，这500条数据在缓存中失效后，可能导致多少读请求，发送读请求到库存服务来，要求更新缓存<br>一般来说，1:1，1:2，1:3，每秒钟有1000个读请求，会hang在库存服务上，每个读请求最多hang多少时间，200ms就会返回<br>在同一时间最多hang住的可能也就是单机200个读请求，同时hang住<br>单机hang200个读请求，还是ok的<br>1:20，每秒更新500条数据，这500秒数据对应的读请求，会有20 * 500 = 1万<br>1万个读请求全部hang在库存服务上，就死定了</li><li>多服务实例部署的请求路由<br>可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上</li><li>热点商品的路由问题，导致请求的倾斜<br>万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的压力过大<br>就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大<br>但是的确可能某些机器的负载会高一些</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2019/07/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/07/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile定义和实现原理"><a href="#volatile定义和实现原理" class="headerlink" title="volatile定义和实现原理"></a>volatile定义和实现原理</h2><p>有volatile变量修饰的共享变量进行写操作时会多出一行汇编代码<br>以lock前缀，将当前处理器缓存行的数据写回到系统内存，这个写回内存的操作会使其他cpu缓存了该内存地址的数据无效。<br>每个处理器遵循缓存一致性协议，自动嗅探总线上传播的数据来检查自己缓存的数据是否过期</p><h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>jdk1.6为了减少获得锁和释放锁带来的性能消耗而引入偏向锁和轻量级锁<br>java每个对象都可以作为锁。表现为3种形式</p><ol><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类</li><li>同步方法块，锁是synchonized括号里的对象<br>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步，方法块表现为monitorenter和monitorexit指令。方法是ACC_SYNCHRONIZED标志</li></ol><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>对象头主要存储HashCode，锁标志位，分代年龄，对象类型的指针。<br>偏向锁位0+锁标志位01=无锁<br>偏向锁位1+锁标志位01=偏向锁<br>所标志位00=轻量级锁<br>锁标志位10=重量级锁</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>why？大多数情况下锁不仅不存在多线程竞争，而且总是由相同的线程多次获得，为了使线程获取锁代价更低。<br>how？当线程访问同步块并获取锁时，在对象头和栈帧中的锁记录里存储锁偏向的线程id<br>what？线程访问同步块时只需简单测试一下Mark Word里是否偏向当前线程，是的话直接进入。如果测试失败，那么先判断偏向锁位是否为1（1表示是偏向锁），如果为0，则使用CAS竞争锁。<br>如果为1，尝试用CAS将对象头偏向锁指向当前线程。<br>当其他线程尝试竞争锁的时候，持有偏向锁的线程才会撤销。<br>偏向锁撤销后， 对象可能处于两种状态。</p><ol><li>不可偏向的无锁状态，之所以不允许偏向， 是因为已经检测到了多于一个线程的竞争， 升级到了轻量级锁的机制。</li><li>不可偏向的已锁 ( 轻量级锁) 状态<br>之所以会出现上述两种状态， 是因为偏向锁不存在解锁的操作， 只有撤销操作。 触发撤销操作时：原来已经获取了偏向锁的线程可能已经执行完了同步代码块， 使得对象处于 “闲置状态”，相当于原有的偏向锁已经过期无效了。此时该对象就应该被直接转换为不可偏向的无锁状态。<br>原来已经获取了偏向锁的线程也可能尚未执行完同步代码块， 偏向锁依旧有效， 此时对象就应该被转换为被轻量级加锁的状态。</li></ol><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>线程在执行同步块前，jvm会现在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的Mark Word复制到锁记录中，官方称为Displaced Mark Word，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>轻量级锁膨胀时， 被锁对象的 markword 会被通过 CAS 操作尝试更新为一个数据结构的指针， 这个数据结构中进一步包含了指向操作系统互斥量(mutex) 和 条件变量（condition variable） 的指针<br>依赖于操作系统的互斥量（mutex） 实现， 其具体的详细机制此处暂不展开， 日后可能补充。 此处暂时只需要了解该操作会导致进程从用户态与内核态之间的切换， 是一个开销较大的操作。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS （Compare And Swap） 指令是一个CPU层级的原子性操作指令。 在 Intel 处理器中， 其汇编指令为 cmpxchg。<br>该指令概念上存在 3 个参数， 第一个参数【目标地址】， 第二个参数【值1】， 第三个参数【值2】， 指令会比较【目标地址存储的内容】和 【值1】 是否一致， 如果一致， 则将【值 2】 填写到【目标地址】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function cas(p , old , new ) returns bool &#123;</span><br><span class="line">    if *p ≠ old &#123; // *p 表示指针p所指向的内存地址</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    *p ← new</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 CPU 层面， CAS 指令的执行是有原子性语义保证的， 如果 CAS 操作放在应用层面来实现， 则需要我们自行保证其原子性。<br>CAS三大问题：</p><ol><li>ABA问题<br>why？A-&gt;B-&gt;A，其实第二次的A值虽然没变，但是他的语义却变了<br>解决：AtomicStampedReference，判断时附带版本号</li><li>循环时间长开销大<br>jvm如果支持处理器pause指令，那么效率会有一定提升。延迟流水线指令，避免循环时内存顺序冲突。</li><li>只能保证一个共享变量的原子操作<br>AtomicReference，多个变量放在一个对象里进行CAS操作</li></ol><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p>java并发采用的是共享内存模型，线程之间共享程序的公共状态，通过读写内存中的公共状态来进行隐式通信。同步是显示进行的，程序员必须显示指定某个方法或某段代码需要在线程间互斥执行。<br>所有实例域、静态域、数组元素都存储在堆内存中。线程共享。<br>局部变量、方法定义参数、异常处理器参数不在线程之间共享。<br>结构：<br>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存存储了该线程以读写共享变量的副本。本地内存是一个抽象概念，涵盖缓存，写缓冲区，寄存器及其他的硬件和编译器优化。<br>jmm确保在不同的编译器和不同的处理器平台之上，禁止特定类型的编译器重排序（不是所有）和通过内存屏障来禁止特定的处理器重排序。提供一致的内存可见性保证。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>为了提高性能，编译器和处理器通常会对指令做重排序，分成3种类型</p><ol><li>编译器优化的重排序</li><li>指令级并行的重排序</li><li>内存系统的重排序<br>as-if-serial语义<br>不管怎么重排序（编译器和处理器为了提高并行度）（单线程）程序的执行结果不能被改变。处理器和编译器不会对存在数据依赖关系的存在做重排序。在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</li></ol><h2 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h2><ol><li>LoadLoad：确保Load1数据的装载先于Load2及所有后续的装载</li><li>StoreStore：确保Store1数据对其他处理器可见（刷新到内存）先于Store2及后续的存储</li><li>LoadStore：确保Load1数据的装载先于Store2及后续存储指令刷新到内存</li><li>StoreLoad：确保Store1数据对其他处理器可见（刷新到内存）先于Load2及所有后续装载指令的装载。会使该屏障之前的内存访问指令完成后，才执行该屏障之后的指令。</li></ol><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JSR-133使用happens-before的概念来阐述操作之间的内存可见性，如果一个操作的执行的结果需要对另一个操作可见，那么这两个操作之间必须存在hb关系。hb仅仅要求前一个操作（执行的结果）对后一个操作可见，并不意味着前一个操作必须在后一个操作之前执行。</p><ol><li>程序顺序规则：一个线程中的每个操作，hb于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，hb于随后对这个锁的加锁</li><li>volatile变量规则：对一个volatile域的写，hb于任意后续对这个volatile域的读</li><li>传递性：A hb B，B hb C，那么A hb C</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始打造CentOs环境</title>
      <link href="/2019/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0CentOs%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0CentOs%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为redis和java应用搭建一个可以运行的环境</p><h2 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h2><p>centos7的iso映像文件，下mini版本即可<br>根据VmWare默认安装就行。</p><h2 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h2><p>安装完后进入终端，输入<strong>ip addr</strong> 不同系统不同版本可能命令不一样，就是主要看他的HADDR，一般都是ens头的网卡。<br><img src="/2019/06/30/从零开始打造CentOs环境/网卡HWADDR.jpg" title="网卡HWADDR"><br><strong>cd /etc/sysconfig/network-script</strong> 进到这个目录找到ifcfg开头的与之前网卡名称相同的文件<br>注意，此时只有vi，还没装vim<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HWADDR=00:0c:29:0b:8c:e6</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">IPADDR=192.168.229.7</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.229.2   //在VmWare虚拟机网络编辑器NAT设置可以看到</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=no</span><br></pre></td></tr></table></figure><br>根据此内容依次修改，wq保存后<strong>systemctl restart network</strong>重启一下网络，用secureCRT测试连接能不能连上，能连上表示设置成功<br>发现ping得通内网，ping不通外网，<strong>vi /etc/resolv.conf</strong><br>添加如下内容,就ping得通了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><br>顺便把防火墙关了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><br>安装vim  <strong>yum -y install vim</strong><br>安装gcc <strong>yum -y install gcc</strong><br>安装wget <strong>yum - y install wget</strong></p><h2 id="配置4台CentOS为ssh免密码互相通信"><a href="#配置4台CentOS为ssh免密码互相通信" class="headerlink" title="配置4台CentOS为ssh免密码互相通信"></a>配置4台CentOS为ssh免密码互相通信</h2><p>（1）首先在三台机器上配置对本机的ssh免密码登录<br>ssh-keygen -t rsa<br>生成本机的公钥，过程中不断敲回车即可，ssh-keygen命令默认会将公钥放在/root/.ssh目录下<br>cd /root/.ssh<br>cp id_rsa.pub authorized_keys<br>将公钥复制为authorized_keys文件，此时使用ssh连接本机就不需要输入密码了<br>（2）接着配置三台机器互相之间的ssh免密码登录<br>使用ssh-copy-id -i hostname命令将本机的公钥拷贝到指定机器的authorized_keys文件中</p><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><p>解压再配环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加如下</span><br><span class="line">export JAVA_HOME=/data/program/software/java8</span><br><span class="line">export JRE_HOME=/data/program/software/java8/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure></p><h2 id="安装perl（给java-nginx-lua）提供环境"><a href="#安装perl（给java-nginx-lua）提供环境" class="headerlink" title="安装perl（给java+nginx+lua）提供环境"></a>安装perl（给java+nginx+lua）提供环境</h2><p>编译过程比较久<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz</span><br><span class="line">tar -xzf perl-5.16.1.tar.gz</span><br><span class="line">cd perl-5.16.1</span><br><span class="line">./Configure -des -Dprefix=/usr/local/perl</span><br><span class="line">make &amp;&amp; make test &amp;&amp; make install</span><br><span class="line">perl -v</span><br></pre></td></tr></table></figure></p><h2 id="安装redis单机"><a href="#安装redis单机" class="headerlink" title="安装redis单机"></a>安装redis单机</h2><p>安装包和程序都安装在根目录/data下<br>官网下载redis<br>下载tcl wget <a href="http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/tcl/tcl8.6.9-src.tar.gz</a> 用来给redis make test</p><ol><li>安装tcl<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf tcl8.6.1-src.tar.gz</span><br><span class="line">cd  /data/tcl8.6.1/unix/</span><br><span class="line">./configure  </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li>安装redis<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf redis.tar.gz</span><br><span class="line">cd redis</span><br><span class="line">make &amp;&amp; make test &amp;&amp; make install</span><br></pre></td></tr></table></figure><img src="/2019/06/30/从零开始打造CentOs环境/redis安装.jpg" title="redis安装"></li></ol><h2 id="redis的生产环境启动方案"><a href="#redis的生产环境启动方案" class="headerlink" title="redis的生产环境启动方案"></a>redis的生产环境启动方案</h2><p>如果一般的学习课程，你就随便用redis-server启动一下redis，做一些实验，这样的话，没什么意义<br>要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动<br>（1）redis utils目录下，有个redis_init_script脚本<br>（2）将redis_init_script脚本拷贝到linux的/etc/init.d目录中，将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号<br>（3）修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）<br>（4）创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件）<br>（5）修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf<br>（6）修改redis.conf中的部分配置为生产环境<br>daemonize    yes                            让redis以daemon进程运行<br>pidfile        /var/run/redis_6379.pid     设置redis的pid文件位置<br>port        6379                        设置redis的监听端口号<br>dir         /var/redis/6379                设置持久化文件的存储位置<br>（7）启动redis，执行cd /etc/init.d, chmod 777 redis_6379，./redis_6379 start<br>（8）确认redis进程是否启动，ps -ef | grep redis<br>（9）让redis跟随系统启动自动启动<br>在redis_6379脚本中，最上面，加入两行注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig:   2345 90 10</span><br><span class="line"># description:  Redis is a persistent key-value database</span><br></pre></td></tr></table></figure><br>chkconfig redis_6379 on</p><h2 id="springboot-jpa-redis-注意事项"><a href="#springboot-jpa-redis-注意事项" class="headerlink" title="springboot jpa-redis 注意事项"></a>springboot jpa-redis 注意事项</h2><ol><li>把reids.conf 里bind 127.0.0.1注释掉，不然无法连接</li><li>把redis保护模式protected-mode yes改成no,不然无法连接</li><li>改一下redisTemplate的序列化，默认jdk序列化会带一串二进制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate(factory);</span><br><span class="line">        //定义key序列化方式</span><br><span class="line">        //RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();//Long类型会出现异常信息;需要我们上面的自定义key生成策略，一般没必要</span><br><span class="line">        //定义value的序列化方式</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        // template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS搭建</title>
      <link href="/2019/05/20/FastDFS%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/05/20/FastDFS%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。</p><ul><li>Tracker Server：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。</li><li>Storage Server：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。</li><li>Client：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。</li></ul><img src="/2019/05/20/FastDFS搭建/FastDFS结构.png" title="FastDFS结构"><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>操作环境：CentOS7 X64，以下操作都是单机环境。<br>我把所有的安装包下载到/data/program/下，解压到当前目录。<br>先做一件事，修改hosts，将文件服务器的ip与域名映射(单机TrackerServer环境)，因为后面很多配置里面都需要去配置服务器地址，ip变了，就只需要修改hosts即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/hosts</span><br><span class="line">增加如下一行，这是我的IP</span><br><span class="line">192.168.229.100 file.jie.com</span><br><span class="line">如果要本机访问虚拟机，在C:\Windows\System32\drivers\etc\hosts中同样增加一行</span><br></pre></td></tr></table></figure></p><h3 id="下载安装-libfastcommon"><a href="#下载安装-libfastcommon" class="headerlink" title="下载安装 libfastcommon"></a>下载安装 libfastcommon</h3><p>libfastcommon是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库，基础环境，安装即可 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line"># wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz</span><br><span class="line">解压</span><br><span class="line"># tar -zxvf V1.0.7.tar.gz</span><br><span class="line"># cd libfastcommon-1.0.7    </span><br><span class="line">安装,记得装gcc yum install gcc</span><br><span class="line"># ./make.sh</span><br><span class="line"># ./make.sh install</span><br><span class="line">libfastcommon.so 安装到了/usr/lib64/libfastcommon.so，但是FastDFS主程序设置的lib目录是/usr/local/lib，所以需要创建软链接。</span><br><span class="line"># ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so</span><br><span class="line"># ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so</span><br><span class="line"># ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so</span><br><span class="line"># ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so </span><br></pre></td></tr></table></figure></p><h3 id="下载安装FastDFS"><a href="#下载安装FastDFS" class="headerlink" title="下载安装FastDFS"></a>下载安装FastDFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">下载FastDFS</span><br><span class="line"># wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz</span><br><span class="line">解压</span><br><span class="line"># tar -zxvf V5.05.tar.gz</span><br><span class="line"># cd fastdfs-5.05</span><br><span class="line">编译、安装</span><br><span class="line"># ./make.sh</span><br><span class="line"># ./make.sh install</span><br><span class="line">默认安装方式安装后的相应文件与目录</span><br><span class="line">A、服务脚本：</span><br><span class="line">/etc/init.d/fdfs_storaged</span><br><span class="line">/etc/init.d/fdfs_tracker</span><br><span class="line">B、配置文件(这三个是作者给的样例配置文件):</span><br><span class="line">/etc/fdfs/client.conf.sample</span><br><span class="line">/etc/fdfs/storage.conf.sample</span><br><span class="line">/etc/fdfs/tracker.conf.sample</span><br><span class="line">C、命令工具在 /usr/bin/ 目录下:</span><br><span class="line">fdfs_appender_test</span><br><span class="line">fdfs_appender_test1</span><br><span class="line">fdfs_append_file</span><br><span class="line">fdfs_crc32</span><br><span class="line">fdfs_delete_file</span><br><span class="line">fdfs_download_file</span><br><span class="line">fdfs_file_info</span><br><span class="line">fdfs_monitor</span><br><span class="line">fdfs_storaged</span><br><span class="line">fdfs_test</span><br><span class="line">fdfs_test1</span><br><span class="line">fdfs_trackerd</span><br><span class="line">fdfs_upload_appender</span><br><span class="line">fdfs_upload_file</span><br><span class="line">stop.sh</span><br><span class="line">restart.sh </span><br><span class="line">FastDFS 服务脚本设置的 bin 目录是 /usr/local/bin， 但实际命令安装在 /usr/bin/下</span><br><span class="line">建立 /usr/bin 到 /usr/local/bin 的软链接</span><br><span class="line"># ln -s /usr/bin/fdfs_trackerd   /usr/local/bin</span><br><span class="line"># ln -s /usr/bin/fdfs_storaged   /usr/local/bin</span><br><span class="line"># ln -s /usr/bin/stop.sh         /usr/local/bin</span><br><span class="line"># ln -s /usr/bin/restart.sh      /usr/local/bin</span><br></pre></td></tr></table></figure><h3 id="配置FastDFS跟踪器-Tracker"><a href="#配置FastDFS跟踪器-Tracker" class="headerlink" title="配置FastDFS跟踪器(Tracker)"></a>配置FastDFS跟踪器(Tracker)</h3><p>进入 /etc/fdfs，复制 FastDFS 跟踪器样例配置文件 tracker.conf.sample，并重命名为 tracker.conf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/fdfs</span><br><span class="line"># cp tracker.conf.sample tracker.conf</span><br><span class="line"># vim tracker.conf</span><br><span class="line">修改内容如下</span><br><span class="line"># Tracker 数据和日志目录地址(根目录必须存在,子目录会自动创建)</span><br><span class="line">base_path=/data/fastdfs/tracker</span><br><span class="line"></span><br><span class="line"># HTTP 服务端口</span><br><span class="line">http.server_port=80</span><br><span class="line"></span><br><span class="line">另外创建tracker基础数据目录，即base_path对应的目录</span><br><span class="line"># mkdir -p /data/fastdfs/tracker</span><br></pre></td></tr></table></figure><br> 防火墙中打开跟踪端口（默认的22122） CentOS7把iptables替换为firewall,而我又把防火墙直接关了，此步骤应该可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">添加如下端口行：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT</span><br><span class="line"></span><br><span class="line">重启防火墙：</span><br><span class="line"># service iptables restart</span><br></pre></td></tr></table></figure><br>centos7.0 没有netstat 和 ifconfig命令问题<br>yum install net-tools  就OK了<br>启动Tracker<br>初次成功启动，会在 /data/fdfsdfs/tracker/ (配置的base_path)下创建 data、logs 两个目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以用这种方式启动</span><br><span class="line"># /etc/init.d/fdfs_trackerd start</span><br><span class="line">也可以用这种方式启动，前提是上面创建了软链接，后面都用这种方式</span><br><span class="line"># service fdfs_trackerd start</span><br><span class="line">查看 FastDFS Tracker 是否已成功启动 ，22122端口正在被监听，则算是Tracker服务安装成功。</span><br><span class="line"># netstat -unltp|grep fdfs</span><br></pre></td></tr></table></figure><br>关闭Tracker命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service fdfs_trackerd stop</span><br></pre></td></tr></table></figure><br>设置Tracker开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig fdfs_trackerd on</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"># vim /etc/rc.d/rc.local</span><br><span class="line">加入配置：</span><br><span class="line">/etc/init.d/fdfs_trackerd start </span><br></pre></td></tr></table></figure></p><h3 id="配置-FastDFS-存储-Storage"><a href="#配置-FastDFS-存储-Storage" class="headerlink" title="配置 FastDFS 存储 (Storage)"></a>配置 FastDFS 存储 (Storage)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入 /etc/fdfs 目录，复制 FastDFS 存储器样例配置文件 storage.conf.sample，并重命名为 storage.conf</span><br><span class="line"># cd /etc/fdfs</span><br><span class="line"># cp storage.conf.sample storage.conf</span><br><span class="line"># vim storage.conf</span><br></pre></td></tr></table></figure><p>编辑storage.conf,标红的需要修改，其它的默认即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)</span><br><span class="line">base_path=/data/fastdfs/storage</span><br><span class="line"></span><br><span class="line"># 逐一配置 store_path_count 个路径，索引号基于 0。</span><br><span class="line"># 如果不配置 store_path0，那它就和 base_path 对应的路径一样。</span><br><span class="line">store_path0=/data/fastdfs/file</span><br><span class="line"></span><br><span class="line"># tracker_server 的列表 ，会主动连接 tracker_server</span><br><span class="line"># 有多个 tracker server 时，每个 tracker server 写一行</span><br><span class="line">tracker_server=file.jie.com:22122</span><br><span class="line"></span><br><span class="line"># 访问端口</span><br><span class="line">http.server_port=80</span><br></pre></td></tr></table></figure><br>防火墙中打开存储器端口（默认的 23000）CentOS7把iptables替换为firewall,而我又把防火墙直接关了，此步骤应该可以跳过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">添加如下端口行：</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT</span><br><span class="line"></span><br><span class="line">重启防火墙：</span><br><span class="line"># service iptables restart</span><br></pre></td></tr></table></figure><br>启动 Storage，启动Storage前确保Tracker是启动的。初次启动成功，会在 /data/fastdfs/storage 目录下创建 data、 logs 两个目录。<br>可以用这种方式启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/fdfs_storaged start</span><br><span class="line"></span><br><span class="line">也可以用这种方式，后面都用这种</span><br><span class="line"># service fdfs_storaged start</span><br></pre></td></tr></table></figure></p><p>关闭Storage命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service fdfs_storaged stop</span><br></pre></td></tr></table></figure><br>查看Storage和Tracker是否在通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure><br><img src="/2019/05/20/FastDFS搭建/Storage和Tracker是否通信.jpg" title="Storage和Tracker是否通信"><br>设置 Storage 开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig fdfs_storaged on</span><br><span class="line">或者：</span><br><span class="line"># vim /etc/rc.d/rc.local</span><br><span class="line">加入配置：</span><br><span class="line">/etc/init.d/fdfs_storaged start</span><br></pre></td></tr></table></figure></p><h3 id="文件上传测试"><a href="#文件上传测试" class="headerlink" title="文件上传测试"></a>文件上传测试</h3><p>修改 Tracker 服务器中的客户端配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/fdfs</span><br><span class="line"># cp client.conf.sample client.conf</span><br><span class="line"># vim client.conf</span><br></pre></td></tr></table></figure><br>修改如下配置即可，其它默认。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Client 的数据和日志目录</span><br><span class="line">base_path=/data/fastdfs/client</span><br><span class="line"></span><br><span class="line"># Tracker端口</span><br><span class="line">tracker_server=file.jie.com:22122</span><br></pre></td></tr></table></figure><br>上传测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /usr/bin/fdfs_upload_file /etc/fdfs/client.conf 111.png</span><br><span class="line">group1/M00/00/00/wKjlZFziAFuASdbVAAWocxCYfsk289.png</span><br></pre></td></tr></table></figure><br><img src="/2019/05/20/FastDFS搭建/文件id.png" title="文件id"></p>]]></content>
      
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构与对象</title>
      <link href="/2019/05/18/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/05/18/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。<br>比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。<br>举个例子，如果客户端执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><ul><li>键值对的<strong>键</strong>是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS。</li><li>键值对的<strong>值</strong>也是一个字符串对象，对象的底层实现是一个保存着字符串“hello world”的SDS。<br>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的。</li></ul><h3 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    //记录buf数组中已使用字节的数量</span><br><span class="line">    //等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    //记录buf数组中未使用字节的数量 最后字节空字符&apos;\0&apos;不计算在len里</span><br><span class="line">    int free;</span><br><span class="line">    //字节数组，用于保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2019/05/18/redis数据结构与对象/sds示例.png" title="SDS示例"><h3 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h3><ol><li>SDS记录了字符串长度信息，不用遍历整个字符串，O(1)，设置和更新SDS长度的工作由SDS的API自动完成</li><li>杜绝缓冲区溢出，sdscat会先检查给定SDS空间是否足够，如果不够，会扩展SDS空间，在进行拼接操作<img src="/2019/05/18/redis数据结构与对象/杜绝溢出1.png" title="在内存中紧邻的两个C字符串">   &lt;string.h&gt;/strcat函数可以将src字符串中的内容拼接到dest字符串的末尾<br>假设要使用strcat函数将redis，修改为redis Cluster，没有为s1分配足够的内存空间，将把s1的数据溢出到s2的空间，修改了s2<img src="/2019/05/18/redis数据结构与对象/杜绝溢出2.png" title="s1的内容溢出到了s2位置">   </li></ol><h3 id="SDS空间分配策略"><a href="#SDS空间分配策略" class="headerlink" title="SDS空间分配策略"></a>SDS空间分配策略</h3><p>由于C字符串长度和底层数组的长度之间存在着这种关联性（N+1），所以每次增长或缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作</p><ul><li>如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。</li><li>如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。<blockquote><p>内存溢出：是指在申请内存时，没有足够的内存供其使用<br>内存泄漏：是指申请内存后，无法释放已申请的内存</p></blockquote>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。<h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无须执行内存重分配。<br>额外分配的未使用空间数量由以下公式决定：<blockquote><p>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。<br>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的len将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。</p></blockquote><h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h4>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是<strong>使用free属性</strong>将这些字节的数量记录起来，并等待将来使用。</li></ul><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。<br>将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</p><h3 id="SDS总结"><a href="#SDS总结" class="headerlink" title="SDS总结"></a>SDS总结</h3><img src="/2019/05/18/redis数据结构与对象/SDS总结.png" title="SDS总结"> ]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2019/05/12/zookeeper/"/>
      <url>/2019/05/12/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务<br>具体介绍可以看官方网站：<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></p><h2 id="zookeeper能做什么"><a href="#zookeeper能做什么" class="headerlink" title="zookeeper能做什么"></a>zookeeper能做什么</h2><ol><li>配置维护：在分布式系统中，一般会把服务部署到n台机器上，服务配置文件都是相同的，如果配置文件的配置选项发生了改变，那我们就得一台一台的去改动。这时候zookeeper就起作用了，可以把zk当成一个高可用的配置存储器，把这样配置的事情交给zk去进行管理，将集群的配置文件拷贝到zookeeper的文件系统的某个节点上，然后用zk监控所有分布式系统里的配置文件状态，一旦发现有配置文件发生了变化，那么每台服务器同步zk的配置文件，zk同时保证同步操作的原子性，确保每个服务器的配置文件都能被更新。</li><li>命名服务：在分布式应用中，通常需要一个完整的命名规则，既能够产生唯一的名称又便于人识别和记住。Zk就提供了这种服务，类似于域名和ip之间对应关系，域名容易记住，通过名称来获取资源和服务的地址，提供者等信息。</li><li>分布式锁：分布式程序分布在不同主机上的进程对互斥资源进行访问的时候需要加锁。这样理解：很多分布式系统有多个服务窗口，但是某个时刻只让一个服务去干活，当这台服务器出问题的时候锁释放，里脊fail over到另外的服务。举例子，比如去某个地方办理证件的时候，只能有一个窗口对你服务，如果这个窗口的柜员有急事走了，那么系统或者经理给你指定另外一个窗口继续服务。</li><li>集群管理：分布式集群中，经常会由于各种原因，比如硬件故障，网络问题，有些节点挂掉、有些节点加进来。这个时候机器需要感知到变化，然后根据变化做出对应的决策，那么zk就实现了类似这种集群的管理。</li><li>队列管理 ：类似一些mq实现队列的功能，这个不常用，不适合高性能的应用。</li></ol><h2 id="zookeeper的角色管理"><a href="#zookeeper的角色管理" class="headerlink" title="zookeeper的角色管理"></a>zookeeper的角色管理</h2><p>领导者（Leader）：领导者负责进行投票的发起和决议，更新系统状态。<br>学习者（Learner）：跟随者（Follower）：用于接受客户请求并向客户端返回结果，在选主过程中参与投票。<br>                 观察者（ObServer）：ObServer可以接受客户端连接，将写请求转发给leader节点，但<br>ObServer不参加投票过程，只同步leader状态。ObServer的目的是为了扩展系统，提高读取<br>速度。<br>客户端（Client）：请求发起方。</p><h2 id="zookeeper设计原则"><a href="#zookeeper设计原则" class="headerlink" title="zookeeper设计原则"></a>zookeeper设计原则</h2><ol><li>最终一致性：客户端（Client）无论连接到哪个zk的节点，展示给他的视图都是一样的。</li><li>可靠性：消息message被到一台服务器接受，那么它到任何服务器都被接受。</li><li>实时性：zk保证在一个时间间隔范围内获得服务器的更新信息，或者服务器失效信息。但是由于网络延时等一些其他原因，zk不能保证两个客户端同事得到跟新或者失效信息。</li><li>等待无关：慢的或者失效的客户端（Client）不得干预快速的client的请求，使得每个client都能有效的等待。</li><li>原子性：更新只能成功或者失败，没有其他中间信息。</li><li>顺序性：包括全局有序和偏序两种：全局有序是指如果再一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li></ol><h2 id="zookeeper工作原理"><a href="#zookeeper工作原理" class="headerlink" title="zookeeper工作原理"></a>zookeeper工作原理</h2><p>用这个命令登录服务器看一下目录结构以及zid：./zkCli.sh  -server 10.15.0.97:2181<br>基本常用的两个命令：ls  /目录    get  /目录<br>zk的核心是原子广播，这个机制保证了各个Server之间的同步，实现这个机制的协议叫做Zab协议。Zab协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者领导者崩溃后，Zab进入恢复模式，当leader被选举出来，然后进行同步模式，同步完成以后，恢复模式结束。<br>为了保证事务的顺序一致性。实现中zxid是一个64位的数字，它高32位是用epoch用来标志leader关系是否改变，每次一个新的leader选举出来，都会拥有一个新的epoch。低32位用来递增计数。<br>（1）Serverid：在配置server时，给定的服务器的标示id。<br>（2）Zxid:服务器在运行时产生的数据id，zxid越大，表示数据越新。<br>（3）Epoch：选举的轮数，即逻辑时钟。随着选举的轮数++</p><h3 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h3><p>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，然后需要重新选举出一个leader。让所有的Server都恢复到一个正确的状态。Zk选举算法有两种，一种是基于basic paxos实现，一种是基于fast paxos算法实现。系统默认的是fast paxos。<br>每个Server在工作过程中有三种状态：<br>LOOKING：当前Server不知道Leader是谁，正在搜寻。<br>LEADING:当前Server即为选举出来的leader。<br>FOLLOWING：leader已经选举出来，当前Server与之同步。<br>首先介绍basic paxos流程（简单介绍）：</p><ol><li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server。</li><li>选举线程首先向所有Server发起一次询问（包括自己）。</li><li>选举线程收到回复后，验证是否是自己发起的询问（验证zxid是否一致），然后获取对方的id（myid），并存储到当前询问对象列表中，最后获取对方提议的leader相关信息（myid，zxid），并将这些信息存储到当次选举的投票记录表中。</li><li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次投票的Server。</li><li>线程将当前zxid最大的Server设置成为当前Server要推荐的Leader，若果此时获胜的Server获得n/2+1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置成自己的状态，否则，继续这个过程，直到leader被选举出来。<br>备注：要使Leader获得多数的Server支持，则Server总数必须是奇数2n+1，且存活的Server的数据不得少于n+1。<img src="/2019/05/12/zookeeper/xuanzhu.jpg" title="选主流程"></li></ol><p>其次介绍fast paxos：</p><ol><li>server启动、恢复准备加入集群，此时都会读取本身的zxid等信息。</li><li>所有server加入集群时都会推荐自己成为leader，然后将（leader id,zxid,epoch）作为广播信息到集群中所有的server，等待集群中的server返回信息。</li><li>收到集群中其他服务器返回的信息，分为两类，服务器处于looking状态，或者其他状态。<br>（1)服务器处于looking状态<br>说先判断逻辑时钟Epoch：<br>（a）如果接受到Epoch大于自己目前的逻辑时钟，那么更新本机的Epoch，同时clear其他服务器发送来的选举数据。然后判断是否需要更新当前自己的选举情况（开始选择的leader id是自己）。<br>判断规则：保存的zxid最大值和leader id来进行判断。先看数据zxid，zxid大的胜出；其次判断leader id，leader id大的胜出；然后再将自身最新的选举结果广播给其他server。<br>（b）如果接受到的Epoch小于目前的逻辑时钟，说明对方处于一个比较低一轮的选举轮数，这时需要将自己的选举情况发送给它即可。<br>（c）如果接收到的Epoch等于目前的逻辑时钟，再根据（a）中的判断规则，将自身的最新选举结果广播给其他server。<br>同时server还要处理两种情况：<br>（a）如果server接收到了其他所有服务器的选举信息，那么则根据这些选举信息确定自己的状态（Following，Leading），结束Looking，退出选举。<br>（b）即时没有收到所有服务器的选举信息，也可以判断一下根据以上过程之后最新的选举leader是不是得到了超过半数以上服务器的支持，如果是则尝试接受最新数据，如果没有最新数据，说明都接受了这个结果，同样也退出选举过程。<br>（2）服务器处于其他状态（Following，Leading）<br>（a）若果逻辑时钟Epoch相同，将该数据保存到recvset，若果所接受服务器宣称自己是leader，那么将判断是不是有半数以上的服务器选举他，若果是则设置选举状态退出选举过程。<br>（b）若果Epoch不相同，那么说明另一个选举过程中已经有了选举结果，于是将选举结果加入到outofelection集合中，再根据outofelection来判断是否可以结束选举，保存逻辑时钟，设置选举状态，并退出选举过程。<img src="/2019/05/12/zookeeper/xuanzhu1.jpg" title="选主流程"><h3 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h3></li><li>leader等待server连接。</li><li>follower连接到leader，将最大的zxid发送给leader。</li><li>leader根据zxid确定同步点。</li><li>同步完成之后，通知follower成为uptodat状态。</li><li>follower收到uptodate消息后，开始接受client请求服务。<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3></li><li>Leader主要功能<br>（a）恢复数据。<br>（b）维持与Learner的心跳，接受Learner请求并判断Learner的请求消息类型。<br>备注：Learner的消息类型主要是ping、request、ack、revalidate。<br>ping消息：是指Learner的心跳信息。<br>request消息：follower发送的提议信息，包括写请求和同步请求。<br>ack消息：是follower对提议的回复，超过半数follower通过，则commit提议。<br>revalidate消息：用来延长session有效时间。</li><li>Follower主要功能<br>（a）向Leader发送请求。<br>（b）接受Leaser消息并进行处理。<br>（c）接受Client的请求，如果是写请求，发送给Leader进行投票。<br>（d）返回结果给Client。<br>备注：follower处理Leader的如下几个消息：<br>ping：心跳信息。<br>proposal消息：leader发起提案，要求follower投票。<br>commit消息：服务器端最新一次提案的消息。<br>uptodate消息：表明同步完成。<br>revalidate消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；sync消息：返回sync信息到client客户端。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
